# BigData

## Ионов Артем группа 6131-010402D

### [1. Лабораторная работа](https://github.com/sat4h/BigData/blob/7380e521c8fa54dd27f0a04f02de5cdb855d0114/LR1/BigDataIonovLR1.ipynb)

### [2. Лабораторная работа](https://github.com/sat4h/BigData/tree/7380e521c8fa54dd27f0a04f02de5cdb855d0114/LR2)

### [3. Лабораторная работа](https://github.com/sat4h/BigData/tree/e851b150374a6c558a3ab270f033f95807d36756/LR3)

### [4. Лабораторная работа](https://github.com/sat4h/BigData/tree/980b97ea7e2454cfc6757875033cd6b7c6351b05/LR4)

**Вопросы по Spark:**

**1. Каким образом можно удалить первый и последний столбец таблицы в Spark?**

Есть два варианта:
1. использовать метод select, перечислив столбцы, которые нужно оставить:
df = df.select(*df.columns[1:-1])

2. Использовать метод drop, удаляя столбцы по имени:
df = df.drop(df.columns[0]).drop(df.columns[-1])

**2. Могут ли возникнуть проблемы если начать обработку RDD в котором 80% записей принадлежит одному ключу?**

При обработке RDD, в котором 80% записей принадлежит одному ключу, возможны проблемы, связанные с несбалансированностью данных. Это может привести к перегрузке (skew).

**3. Для чего используется класс ValueState?**

ValueState обычно используется для хранения состояния в пределах одного оператора или функции, чтобы обеспечить сохранение и доступ к состоянию во время обработки потока данных.

**4. В соответствие с какой логикой распределяются сообщения от вышестоящего оператора нижестоящему при параллелизме операторов больше 1? Можно ли эту логику поменять?**

При параллелизме операторов больше 1 сообщения от вышестоящего оператора нижестоящему могут быть распределены по различным логикам в зависимости от системы обработки данных и ее конфигурации. Одним из распространенных подходов является распределение сообщений по ключу (key-based partitioning). При распределении по ключу каждое сообщение ассоциируется с определенным ключом, и система обработки данных использует этот ключ для определения того, к какому оператору отправить сообщение. 

Логика распределения сообщений может меняться в зависимости от системы и ее настроек. Некоторые системы обработки данных позволяют настроить пользовательские распределители, позволяющие изменить логику распределения сообщений. 

**5. Какие виды узлов может создать клиент ZooKeeper?**
1. Persistent nodes: Постоянные узлы, эти узлы сохраняются, даже если клиент, создавший Znode, отключается. По умолчанию все Znodes являются постоянными, если не указано иное.
2. Ephemeral nodes: Временный, узел, созданный клиентом, будет существовать только до разрыва связи между клиентом и сервером ZooKeeper. При разрыве связи временный узел автоматически удалится.
3. Sequential nodes: последовательный узел, клиент может запросить создание последовательного узла, и ZooKeeper автоматически добавит уникальное числовое значение в имя узла. Это гарантирует уникальность имени узла для каждого создания.
